#!/usr/bin/env python3
# coding=utf-8

import sys
import struct

DOUBLE_SAFE_FORMAT="{:.17g}"

def double_to_literal(b):
    return DOUBLE_SAFE_FORMAT.format(struct.unpack("d", b)[0])

data = bytes()
with open(sys.argv[1], "rb") as f:
    buf = f.read()
    while len(buf)>0:
        data += buf
        buf = f.read()

time_offset, time_delta, count = struct.unpack("qqq", data[0:8*3])

hex_data = [double_to_literal(data[b:b+8]) for b in range(8*3, len(data), 8)]

print("/* code generated by gen-geocentric-data-code.py */")

# Sanity check that converting data to float and conveting them back
# provide the same result.
c = 0
e = 0
for b in range(8*3, len(data), 8):
    c += 1
    h = data[b:b+8]
    o = struct.pack("d", float(double_to_literal(h)))
    if h != o:
        e+=1
        print(f"/* Error: {c} {d:.18g} ({struct.unpack('d', o)[0]:.18g}) {h.hex()} != {o.hex()} */")
print(f"/* invalid conversions: {e}/{c}  */")

if e != 0:
    exit(1)

print("#include <cstdint>")

print('#include "sg2_data_handler.hxx"')

print("namespace sg2 {")
print(f"int64_t const _geocentric_data_time_offset = {time_offset}l;")
print(f"int64_t const _geocentric_data_time_delta = {time_delta}l;")
print(f"int64_t const _geocentric_data_xcount = {count}l;")
print("geocentric_data_format const _geocentric_data[_geocentric_data_xcount] = {")
print(",\n".join(("{"+",".join(hex_data[n:n+3])+"}" for n in range(0, len(hex_data), 3))))
print("};")
print("} // namespace sg2")

